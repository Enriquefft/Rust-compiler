PlainIdent = letter , { letter | digit | "_" } ;
Ident      = PlainIdent ;   (* PlainIdent must not be Keyword *)

(* NOTE: Raw identifiers ("r#" prefix) are in the Rust spec but NOT implemented
   in this compiler. The grammar originally included:
     Ident = PlainIdent | "r#" , PlainIdent ;
   This was removed to match the actual parser/lexer implementation. *)

IntLit     = digit , { digit } ;
FloatLit   = digit , { digit } , "." , digit , { digit } ;
BoolLit    = "true" | "false" ;
StringLit  = '"' , { char - '"' } , '"' ;
CharLit    = "'" , char , "'" ;

Keyword    = "fn" | "struct" | "impl" | "type" | "let" | "mut"
           | "if" | "else" | "while" | "for" | "in" | "return" | "as" | "self"
           | "const" | "unsafe"
           | BoolLit ;

Crate  = { Item } ;

Item   = FnItem | StructItem | ImplItem | TypeAliasItem | ConstItem | ";" ;

TypeAliasItem = "type" , Ident , [ GenParams ] , "=" , Type , ";" ;

ConstItem     = "const" , Ident , ":" , Type , "=" , Expr , ";" ;

StructItem    = "struct" , Ident , [ GenParams ] ,
                "{" , [ Field , { "," , Field } , [ "," ] ] , "}" ;
Field         = Ident , ":" , Type ;

FnItem        = "fn" , Ident , [ GenParams ] ,
                "(" , [ SelfParam | Param , { "," , Param } , [ "," ] ] , ")" ,
                [ "->" , Type ] , Block ;

ImplItem      = "impl" , [ GenParams ] , Type  ,
                "{" , { FnItem | ";" } , "}" ;

GenParams = "<" , Ident , { "," , Ident } , ">" ;
GenArgs   = "<" , Type  , { "," , Type  } , ">" ;

Path      = Ident , { "::" , Ident } , [ GenArgs ] ;

Type   = PrimType
       | "[" , Type , ";" , ConstExpr , "]"
       | "*" , ( "const" | "mut" ) , Type
       | "&" , [ "mut" ] , Type
       | "fn" , "(" , [ Type , { "," , Type } ] , ")" , "->" , Type
       | Path ;

PrimType  = "u32" | "u64" | "usize" | "i32" | "i64" | "f32" | "f64"
          | "bool" | "char" | "str" | "String" ;

ConstExpr = IntLit | Ident ;

Block = "{" , { Stmt } , [ Expr ] , "}" ;

(* Stmt includes block expressions (bare blocks and unsafe blocks) which
   can appear without a trailing semicolon when used at statement level. *)
Stmt  = LetStmt | WhileStmt | IfStmt | ReturnStmt | ForStmt 
      | Block | UnsafeBlock 
      | Expr , ";" 
      | ";" ;

ForStmt = "for" , Pattern , "in" , Expr , Block ;

LetStmt    = "let" , [ "mut" ] , Pattern ,
             [ ":" , Type ] , [ "=" , Expr ] , ";" ;

Pattern    = Ident | "_" ;

WhileStmt  = "while" , Expr , Block ;

IfStmt     = "if" , Expr , Block , [ "else" , ( IfStmt | Block ) ] ;

ReturnStmt = "return" , [ Expr ] , ";" ;

PlaceExpr = PlaceBase , { ("[" , Expr , "]") | ("." , Ident) } ;

PlaceBase = Ident | "*" , PlaceExpr | "(" , PlaceExpr , ")" ;

Expr        = Assign | UnsafeBlock;

UnsafeBlock = "unsafe" , Block ;

Assign      = IfExpr
            | PlaceExpr , ("=" | "+=" | "-=" | "*=" | "/=") , Assign ;

IfExpr      = "if" , Expr , Block , "else" , ( IfExpr | Block )
            | Or ;

Or          = And , { "||" , And } ;
And         = Eq  , { "&&" , Eq  } ;
Eq          = Rel , { ("==" | "!=") , Rel } ;
Rel         = Range , { ("<" | "<=" | ">" | ">=") , Range } ;
Range       = Add , { (".." | "..=") , Add } ;
Add         = Mul , { ("+" | "-") , Mul } ;
Mul         = Cast, { ("*" | "/" | "%") , Cast } ;

Cast        = Unary , { "as" , Type } ;

Unary       = { "!" | "-" | "*" | "&" , [ "mut" ] } , Postfix ;

Postfix     = Primary , { Call | Index | Field | Method } ;

Call        = "(" , [ Expr , { "," , Expr } , [ "," ] ] , ")" ;
Index       = "[" , Expr , "]" ;
Field       = "." , Ident ;
Method      = "." , Ident , Call ;

MacroCall   = Path , "!" , Call ;

Primary     = Literal
            | MacroCall
            | Path
            | "[" , [ Expr , { "," , Expr } , [ "," ] ] , "]"
            | Path , "{" , [ Init , { "," , Init } , [ "," ] ] , "}"
            | "|" , [ Param , { "," , Param } , [ "," ] ] , "|" , ( Expr | Block )
            | "(" , Expr , ")"
            | Block ;

Init        = Ident , [ ":" , Expr ] ;  (* Shorthand: "{ x }" means "{ x: x }" - field name as variable reference *)

Literal     = IntLit | FloatLit | BoolLit | CharLit | StringLit ;

Param       = Pattern , [ ":" , Type ] ;

SelfParam     = "self"
              | "&" , "self"
              | "&" , "mut" , "self" ;
